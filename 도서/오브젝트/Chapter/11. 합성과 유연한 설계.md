#객체지향/composition-합성 
- 상속
	- 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용한다.
	- 의존성은 컴파일 타임에서 해결된다.
	- `is-a 관계` 라고 부른다.
	- 상속 관계는 클래스 사이의 정적인 관계
	- 코드 작성 시점에 결정한 상속 관계는 변경이 불가능
	- 부모 클래스 안에 구현된 코드 자체를 재사용한다.
	- 클래스 사이의 높은 결합도 발생

- 합성
	- 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다.
	- 두 객체 사이의 의존성은 런타임에 해결된다.
	- `has-a 관계` 라고 부른다.
	- 객체 사이의 동적인 관계
	- 실행 시점에 동적으로 변경 할 수 있다.
	- 포함되는 객체의 퍼블릭 인터페이스를 재사용 한다. 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경할 수 있다.
	- 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있다.

> *합성* 은 구현에 의존하지 않는다. 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존하므로 구현이 변경되더라도 영향을 최소화 할 수 있다.

![](../images/image07.png)
# 🍊 상속을 합성으로 변경하기
> 상속을 남용 했을 때 생길 수 있는 세가지 문제

- [0] 불필요한 인터페이스 상속 문제


```java title="Properties를 합성 관계로 변경"
public class Properties {
	private Hashtable<String, String> properties = new Hashtable <>();

	public String setProperty(String key, String value){
		return properties.put(key, value);
	}

	public String getProperty(String key){
		return properties.get(key);
	}
}
```

- 합성 관계로 변경하기 위해 `Properties` 클래스에서 상속 관계를 제거하고 `Hashtable` 을 `Properties` 의 인스턴스 변수로 포함 시키면 합성 관계로 변경 할 수 있다.

- [1] 메서드 오버라이딩의 오작용 문제

```java title="InstrunmentedHashSet를 합성 관계로 변경"
public class InstrunmentedHashSet<E>{
	private int addCount = 0;
	private Set<E> = set;

	public InstrunmentedHashSet(Set<E> set) {
		this.set = set;
	}

	public boolean add(E e){
		addCount++;
		return set.add(e);
	}

	public boolean addAll(Collection<? extends E> c){
		addCount += c.size();
		return set.addAll(c);
	}

	public int getAddCount(){
		return addCount;
	}
}
```

- 위의 `Properties` 를 합성으로 변경한 이유는 불필요한 오퍼레이션들이 퍼블릭 인터페이스에 스며드는것을 방지하기 위해서고
- `InstrumentedHashSet` 의 경우에 `HashSet` 이 제공하는 퍼블릭 인터페이스를 그대로 제공해야 한다.
- `InstrumentedHashSet` 이 `Set` 인터페이스를 실체화하면서 내부에 `HashSet` 의 인스턴스를 합성하면 `HashSet` 에 대한 구현 결합도는 제거하면서 퍼블릭 인터페이스는 그대로 유지할 수 있다.


- [2] 부모 클래스와 자식 클래스의 동시 수정 문제

```java
public class PersonalPlaylist{
	private Playlist playlist = new Playlist();

	public void append(Song song){
		playlist.append(song);
	}

	public void remove(Song song){
		playlist.getTracks().remove(song);
		playlist.getSingers().remove(song.getSinger());
	}
}
```

- `Playlist` 의 경우에는 합성으로 변경하더라도 함께 수정되는 문제가 해결되지 않는다.
- 그래도 *상속보다 합성을 사용하는게 더 좋다* 
	- 향후 `Playlist` 의 내부 구현을 변경하더라도 파급효과를 최대한 `PersonalPlaylist` 내부로 캡슐화 할 수 있기 때문이다.
- **구현에 대한 결합보다(상속) 인터페이스에 대한 결합(합성)이 더 좋다**

## 결론
- 합성을 사용하면 위의 세가지 문제를 해결 할 수 있다.
- 상속을 합성으로 바꾸는 방법은 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.


# 🍉 상속으로 인한 조합의 폭발적인 증가
