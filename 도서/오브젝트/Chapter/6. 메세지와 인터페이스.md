
- 객체지향 프로그래밍의 가장 중요한 재료는 클래스가 아니라 객체들이 주고받는 메세지다.

# 🐵 협력과 메세지

## 클라이언트 - 서버 모델
- 협력은 어떤 객체가 다른 객체에게 메세지를 통해 무언가를 요청할 때 시작된다.
	- 클라이언트 : 메세지를 전송하는 객체
	- 서버 : 메세지를 수신하는 객체

> 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다.

- 협력의 관점에서 객체의 두가지 종류의 메세지 집합
	1. 객체가 수신하는 메세지의 집합
	2. 외부의 객체에게 전송하는 메세지의 집합
- 협력에 적합한 객체를 설계하기 위해서 객체가 수신하는 메세지집합과 외부에 전송하는 메세지의 집합도 함께 고려해야 한다.

> 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력 해야 한다.


## 메세지와 메세지 전송
- `메세지(message)` 
	- 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.
	- `오퍼레이션명(operation name)` 과 `인자(argument)` 로 구성된다.
- `메세지 전송(message sending)` : 한 객체가 다른 객체에게 도움을 요청하는 것.
- `메세지 전송자(message sender)` : 메세지를 전송하는 객체
- `메세지 수신자(message receiver)` : 메세지를 수신하는 객체

> 메세지는 오퍼레이션명과 인자로 구성되고 메세지 전송은 여기에 메세지 수신자를 추가한것
> 메세지 전송은 메세지 수신자, 오퍼레이션명, 인자의 조합이다.

![](../images/image06.png)

```typescript title="메세지 전송 표기법"
condition.isSatisfiedBy(screening);
```

- condition : 수신자
- isSatisfiedBy : 오퍼레이션명
- (screening) : 인자


## 메세지와 메서드
- *메서드* : 메세지를 수신했을 때 실제로 실행되는 함수 또는 프로시저

> 전통적인 방식의 개발자는 코드의 의미가 컴파일 시점과 실행 시점에 동일한 코드를 작성하는데
> 객체지향적인 방식의 객체는 메세지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에
> **컴파일 시점과 실행 시점의 의미가 달라질 수 있다.** 
> **실행 시점에 실제로 실행되는 코드는 메세지를 수신하는 객체의 타입에 따라 달리지기 때문에** 우리는 그저 메세지에 응답할 수 있는 객체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라고 믿을 수 밖에 없다.

- 메세지 전송자와 메세지 수신자는 서로에 대한 상세한 정보를 알지 못한 채 메세지라는 끈을 통해서만 연결된다.
- 실행 시점에 메세지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춘다.


## 퍼블릭 인터페이스와 오퍼레이션

- 퍼블릭 인터페이스(public interface) : 객체가 의사소통을 위해 외부에 공개하는 메세지의 집합
- 오퍼레이션(operation) : 퍼블릭 인터페이스에 포함된 메세지.
	- 수행 가능한어떤 행동에 대한 추상화
- 메서드 : 메세지를 수신했을 때 실제로 실행되는 코드

> 예제 코드에서 `DiscountCondition` 인터페이스에서 `isSatisfiedBy` 가 *오퍼레이션* 이고
> `SequenceCondition` 과 `PeriodCondition` 에 정의된 각각의 `isSatisfiedBy` 는 실제 구현을 포함하기 때문에 *메서드* 라고 한다.

## 시그니처
- 시그니처 : 오퍼레이션이나 메서드의 명세를 나타낸 것으로 이름과 인자의 목록을 포함한다.

# 🌼 인터페이스와 설계 품질
- 좋은 인터페이스는 *최소한의 인터페이스* 와 *추상적인 인터페이스* 라는 조건을 만족해야 한다.
- 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법은 책임 주도 설계(RDD) 방법 이다.

- [0] 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법

- 디미터 법칙
- 묻지 말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리


## 디미터 법칙
- 객체의 내부구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.
- 캡슐화를 다른 관점에서 표현한것
	- 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.
- 객체가 자기 자신을 책임지는 자율적인존재여야 한다.

> 디미터 법칙을 따르기 위해서는 클래스가 특정 조건을 만족하는 대상에게만 메세지를 전송하도록 프로그래밍 해야한다.
> 아래는 클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메세지를 전송해야 하는 조건

- this 객체
- 메서드의 매개변수
- this의 속성
- this의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체

## 묻지 말고 시켜라
- 훌륭한 메세지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다.
- 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.
- 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.
- 자연스럽게 정보 정문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.

## 의도를 드러내는 인터페이스
- 메서드 명명법
	1. 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 것이다.
	2. '어떻게' 가 아니라 '무엇'을 하는지를 드러내는 것
- 메서드의 목적을 효과적으로 전달하고자 의도를 드러내는 선택자를 사용해 메서