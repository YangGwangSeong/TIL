
> 객체지향에서 코드를 재사용하는 전통적인 방법은 클래스를 추가하는 방법이다.
> 가장 대표적인 기법으로는 상속이 있다.

# 🍙 상속과 중복코드

## DRY 원칙
- DRY 원칙 : `Don't Repeat Yourself` 반복하지 마라는 뜻
- 중복 코드는 변경을 방해한다.
- 중복 코드가 가지는 문제점은 코드를 수정하는데에 필요한 노력을 몇배로 늘린다.

## 중복과 변경
> 예시
> 한달에 한번씩 가입자별로 전화 요금을 계산하는 간단한 애플리케이션

```ts title="예제 중복코드"
/**
 * 개별 통화 기간을 저장하는 Call 클래스
 * 통화 시작 시간(from)과 종료 시간(to)을 저장한다.
 */
class Call {
  private from: Date;
  private to: Date;
  constructor(from: Date, to: Date) {
    this.from = from;
    this.to = to;
  }

  public get Duration(): number {
    return (this.to.getTime() - this.from.getTime()) / 1000;
  }

  public get From(): Date {
    return this.from;
  }
}

/**
 * 전체 통화 목록에 대해 알고 있는 정보 정문가에게 요금을 계산 할 책임을 할당 해야 한다.
 * 그게 바로 Phone클래스이다.
 * amount : 단위요금을 저장
 * seconds: 단위 시간을 저장
 * calls: 전체 통화 목록을 저장
 */
class Phone {
  private amount: Money;
  private seconds: number;
  private calls: Call[] = [];

  constructor(amount: Money, seconds: number) {
    this.amount = amount;
    this.seconds = seconds;
  }

  public call(call: Call): void {
    this.calls.push(call);
  }

  public get Calls(): Call[] {
    return this.calls;
  }

  public get Amount(): Money {
    return this.amount;
  }

  public get Seconds(): number {
    return this.seconds;
  }

  public calculateFee() {
    let result = Money.ZERO;

    for (const call of this.calls) {
      result = result.plus(this.amount.times(call.Duration / this.seconds));
    }

    return result;
  }
}

class Money {
  static readonly ZERO = Money.wons(0);

  constructor(private _amount: number) {}

  static wons(amount: number) {
    return new Money(amount);
  }

  public plus(money: Money): Money {
    return new Money(this._amount + money._amount);
  }

  public minus(money: Money): Money {
    return new Money(this._amount - money._amount);
  }

  public times(percent: number): Money {
    return new Money(this._amount * percent);
  }

  public get Amount(): number {
    return this._amount;
  }
}

/*
*
* 10초당 5원씩 부과되는 요금제에 가입한 사용자가 1분동안 두번 통화를 한 경우 요금 계산
*/
const phone = new Phone(Money.wons(5), 10);

phone.call(
  new Call(new Date(2018, 0, 1, 12, 10, 0), new Date(2018, 0, 1, 12, 11, 0))
);

phone.call(
  new Call(new Date(2018, 1, 2, 12, 10, 0), new Date(2018, 1, 2, 12, 11, 0))
);

console.log(phone.calculateFee()); // Money { _amount: 60 }

/*
* 심야 할인 요금제를 위한 NightlyDiscountPhone 클래스
*/
class NightlyDiscountPhone {
  private static LATE_NIGHT_HOUR: number = 22;

  private nightlyAmount: Money;
  private regularAmount: Money;
  private seconds: number;
  private calls: Call[] = [];

  constructor(nightlyAmount: Money, regularAmount: Money, seconds: number) {
    this.nightlyAmount = nightlyAmount;
    this.regularAmount = regularAmount;
    this.seconds = seconds;
  }

  public calculateFee() {
    let result = Money.ZERO;

    for (const call of this.calls) {
      if (call.From.getHours() >= NightlyDiscountPhone.LATE_NIGHT_HOUR) {
        result = result.plus(
          this.nightlyAmount.times(call.Duration / this.seconds)
        );
      } else {
        result = result.plus(
          this.regularAmount.times(call.Duration / this.seconds)
        );
      }
    }

    return result;
  }
}

```

> 요구사항은 항상 변한다.
> 여기서 만약에 '심야 할인 요금제' 라는 새로운 요금 방식을 추가해야 한다는 요구사항이 발생
> 심야 할인 요금제는 밤 10시 이후의 통화에 대해 요금을 할인 해주는 방식이다.

- 심야 할인 요금제`(NightlyDiscountPhone)` 
	- 밤 10시 이전에 적용할 통화요금 `(regularAmount)` 
	- 밤 10시 이후에 적용할 통화요금 `(nightlyAmount)` 
	- 단위 시간 `(seconds)` 
	- ex) 10시 이전에 10초당 5원이고, 10시 이후에 10초당 2원이면 seconds는 10초, regularAmount는 5원, nightlyAmount는 2원

> `Phone` 과 `NightlyDiscountPhone` 사이에는 중복 코드가 존재
### 중복 코드 수정하기
> 통화 요금에 부과 할 세금을 계산 하는 기능 추가
> 통화 요금 계산 로직을 `Phone` 과 `NightlyDiscountPhone` 양쪽 모두 수정해야 한다.

```ts title="taxRate 추가"
// Phone 클래스
class Phone {
	private taxRate: number;

	constructor(amount: Money, seconds: number, taxRate: number) {
	    // ....
	    this.taxRate = taxRate;
	}

	public calculateFee(): Money {
		let result = Money.ZERO;

	    for (const call of this.calls) {
	      result = result.plus(this.amount.times(call.Duration / this.seconds));
	    }
	    
		// taxRate 추가 계산 로직
	    return resul.plus(result.times(this.taxRate));
		
	}
}

// NightlyDiscountPhone
class NightlyDiscountPhone {
  // ...

  constructor(nightlyAmount: Money, regularAmount: Money, seconds: number, taxRate: number) {
    // ...
    this.taxRate = taxRate;
  }

  public calculateFee() {
    let result = Money.ZERO;

    for (const call of this.calls) {
      if (call.From.getHours() >= NightlyDiscountPhone.LATE_NIGHT_HOUR) {
        result = result.plus(
          this.nightlyAmount.times(call.Duration / this.seconds)
        );
      } else {
        result = result.plus(
          this.regularAmount.times(call.Duration / this.seconds)
        );
      }
    }

	// taxRate 추가 계산 로직
    return result.minus(result.times(this.taxRate));
  }
}
```
### 타입 코드 사용하기
- 중복 코드를 제거하기 위해 클래스를 하나로 합치는 방법이 있지만 낮은 응집도와 높은 결합도라는 문제에 시달리게 된다.
### 결론
- 코드를 `DRY` 하게 만들기 위해 노력하라.

## 상속을 이용해서 중복 코드 제거하기
#객체지향/상속

- 상속의 기본 아이디어는 이미 존재하는 클래스와 유사한 클래스가 필요하다면 코드를 복사하지 말고 상속을 이용해 코드를 재사용하는 것이다.
- 상속의 단점은 결합도를 높이고 상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다.


> 10시 이전의 요금제는 `Phone` 에 구현된 로직을 재사용하고 10시 이후의 통화 요금을 계산하는 로직만 `NightlyDiscountPhone` 에서 구현

- 심야 할인 요금제의 규칙
	- 밤 10시 이전 : 10초당 5원(regularAmount = 5원, seconds = 10초)
	- 밤 10시 이후 : 10초당 2원(nightlyAmount = 2원, seconds = 10초)
		- Ex) 밤 10시 이전에 2번 통화 40초, 50초라면
			- (40초 / 10초 x 5원) + (50초 / 10초 x 5원) = 45원
		- Ex) 밤 10시 이후
			- (40초 / 10초 x 2원) + (50초 / 10초 x 2원) = 18원
		- Ex) 40초는 밤 10시 이전 50초는 밤 10시 이후
			- (40초 / 10초 x 5원) + (50초 / 10초 x 2원) = 30원

```ts
class NightlyDiscountPhone extends Phone {
  private static LATE_NIGHT_HOUR: number = 22;
  private nightlyAmount: Money;

  constructor(nightlyAmount: Money, regularAmount: Money, seconds: number) {
    super(regularAmount, seconds);
    this.nightlyAmount = nightlyAmount;
  }

  override calculateFee(): Money {
    // 부모 클래스의 calculateFee 호출
    let result = super.calculateFee();

    let nightlyFee = Money.ZERO;

    for (const call of super.Calls) {
      if (call.From.getHours() >= NightlyDiscountPhone.LATE_NIGHT_HOUR) {
        nightlyFee = nightlyFee.plus(
          super.Amount.minus(this.nightlyAmount).times(
            call.Duration / super.Seconds
          )
        );
      }
    }

    return result.minus(nightlyFee);
  }
}

const nightlyDiscountPhone = new NightlyDiscountPhone(
  Money.wons(2),
  Money.wons(5),
  10
);

/**
 * 10시 이전 통화 계산
 */
// nightlyDiscountPhone.call(
//   new Call(new Date(2018, 0, 1, 13, 0, 0), new Date(2018, 0, 1, 13, 0, 40))
// ); // 40초 통화

// nightlyDiscountPhone.call(
//   new Call(new Date(2018, 0, 1, 13, 0, 0), new Date(2018, 0, 1, 13, 0, 50))
// ); // 50초 통화

// console.log(nightlyDiscountPhone.calculateFee()); // Money { _amount: 45 }

/**
 * 10시 이후 통화 계산
 */
nightlyDiscountPhone.call(
  new Call(new Date(2018, 0, 1, 22, 0, 0), new Date(2018, 0, 1, 22, 0, 40))
); // 10시 이후 40초 통화

nightlyDiscountPhone.call(
  new Call(new Date(2018, 0, 1, 22, 0, 0), new Date(2018, 0, 1, 22, 0, 50))
); // 10시 이후 50초 통화

console.log(nightlyDiscountPhone.calculateFee()); // Money { _amount: 18 }
```

> 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는것은 코드를 이해하기 어렵게 만들뿐만 아니라 직관에도 어긋날 수 있다.

## 강하게 결합된 Phone과 NightlyDiscountPhone
> 세금 부과 로직을 추가 하기 위해 `Phone` 을 수정할때 `NightlyDiscountPhone` 도 함께 수정 해주어야 한다.
> 그 이유는 super참조를 통해 부모 클래스의 메서드에서 계산을하고 10시 이후에는 NightlyDiscountPhone에서 계산 하기 때문에 세금 부과 로직이 추가되면 두 클래스에 다 추가해주어야 한다.




# 🍙 취약한 기반 클래스 문제

- 상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다.
- 상속은 높은 결합도로 인해 부모 클래스를 점직적으로 개선하는것은 어렵게 만든다.
- 최악의 경우에는 모든 자식 클래스를 동시에 수정하고 테스트해야 할 수 도 있다.
- 캡슐화를 약화시키고 결합도를 높인다.
- 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다.

## 불필요한 인터페이스 상속 문제


# 상속을 위한 경로 1: 강력한 결합도
- 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출 할 경우 두 클래스는 강하게 결합된다.
- 부모 클래스의 변경에 의해 자식 클래스가 영향을 받을 수 있게 된다.
- `super` 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.

