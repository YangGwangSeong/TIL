# 15. 디자인 패턴과 프레임워크

- *디자인 패턴* : 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법.
	- 목적은 설계를 재사용하는 것이다.
- *프레임 워크* : 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.
	- 목적은 설계와 코드를 함께 재사용하기 위한것이다.

# 🦀 디자인 패턴과 설계 재사용

## 소프트웨어 패턴
- 패턴의 핵심적인 특징
	- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
	- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통 할 수 있다.
	- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
	- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

> 패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 '아이디어'다.

- 패턴으로 인정하기 위한 조건 3의 규칙
	- 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는점이다.
	- 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 패턴의 '이름' 이다.
	- 패턴은 홀로 존재하지 않는다.
## 패턴과 책임-주도 설계
- 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
- 패턴의 구성 요소는 클래스가 아니라 *역할* 이다.
- 디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.

> 디자인 패턴 예시

- `STRATEGY` 패턴 : 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공한다.
- `BRIDGE` 패턴 : 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만든다.
- `OBSERVER` 패턴 : 유연한 통지 메커니즘을 구축하기 위해 객체간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.

> 8장의 중복 할인 설계의 기본 구조는 `COMPOSITE` 패턴을 따른다.
## 캡슐화와 디자인 패턴
> 영화 예매 시스템에서 사용한 설계는 `STRATEGY` 패턴을 적용한 예이다.

- `STRATEGY` 패턴 : 목적은 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 합성을 이용한다.(합성)
- `TEMPLATEMETHOD` 패턴 :
	- 알고리즘을 캡슐화하기 위해 상속 관계를 사용
	- 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화 할 수 있는 디자인 패턴 (상속)
- `DECORATOR` 패턴 :
	- 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴
	- 객체의 행동을 결합하기 위해서 객체 합성을 사용한다.
	- 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화 할 수 있다.
	- 핸드폰 과금 시스템 설계에 사용.
- `COMPOSITE` 패턴 :
	- 개별 객체와 복합 객체라는 객체의 수와 관련된 변경을 캡슐화 하는 것이 목적이다.
	- 8장의 중복 할인 정책 구조에서 `Movie` 는 자신과 협력해야 하는 `DiscountPolicy` 인스턴스가 단일 객체인지 복합 객체인지를 알 필요가 없다.
	- 협력하는 객체의 수를 변경하더라도 `Movie` 에 형향을 미치지 않는다.
## 패턴은 출발점이다
- 패턴은 출발점이지 목적지가 아니다.
	- 명확한 트레이드오프 없이 패턴을 남용하면 설계가 불필요하게 복잡해지게 된다.
	- 패턴을 적용할 때는 항상 설계를 좀 더 단순하고 명확하게 만들 수 있는 방법이 없는지를 고민해야 한다.
- 패턴은 공통적인 문제에 적절한 해법을 제공하지만 공통적인 해법이 우리가 직면한 문제에 적합하지 않을 수 도 있다.
- 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.
- 정당한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이고, 패턴은 복잡성의 가치가 단순성을 넘어설 때만 정당화되어야 한다.

# 🐭 프레임 워크와 코드 재사용

## 코드 재사용 vs 설계 재사용
- 재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다.

> 설계를 재사용 하면서도 유샇나 코드를 반복적으로 구현하는 문제를 피할 수 있는 방법은 없을까?
> : 프레임워크

- 프레임워크 : 
	- 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계
	- 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징 할 수 있는 애플리케이션의 골격(skeleton)을 의미한다.

> 프레임 워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다.
> 프레임 워크는 애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함한다.
> 프레임 워크는 애플리케이션을 확장할 수 있도록 부분적으로 구현된 추상 클래스와 인터페이스 집합뿐만 아니라 추가적인 작업 없이도 재사용 가능한 종류의 컴포넌트도 함께 제공한다.

## 상위 정책과 하위 정책으로 패키지 분리하기
 - 프레임워크의 핵심은 추상 클래스나 인퍼테이스와 같은 추상화라고 할 수 있다.
 - 추상 클래스와 인터페이스가 일관성 있는 협력을 만드는 핵심 재료이다.

> 동일한 역할을 수행하는 객체들 사이의 협력 구조를 다양한 애플리케이션 안에서 재사용하기 위해선 변하는 것과 변하지 않는 것을 서로 분리해야 한다.

- 변하는 것 : 상위 정책에 속하는 역할들의 협력 구조.
- 변하지 않는 것 : 구체적인 세부 사항.
## 제어 역전 원리
- 상위 정책을 재사용한다는 것은 결국 도메인에 존재하는 핵심 개념들 사이의 협력 관계를 재사용한다는 것을 의미한다.
- 객체지향 설계의 재사용은 개별 클래스가 아니라 객체들 사이의 공통적인 협력 흐름으로부터 나온다.
- 의존성 역전 원리는 전통적인 설계 방법과 객체지향을 구분하는 가장 핵심적인 원리다.
- 의존성 역전 원리에 따라 구축되지 않는 시스템은 협력 흐름을 재사용할 수 도 없으며 변경에 유연하게 대처할 수 도 없다.

*훌륭한 객체지향 설계는 의존성 역전된 설계다* 
> 객체지향 설계의 증명이 바로 이와 같은 의존성의 역전이다.
> 프로그램의 의존성이 역전돼 있다면, 이것은 객체지향 설계를 갖는것이다. 그게 아니라면 절차적 설계를 갖는 것이다.

- 전통적인 구조 : 상위 정책의 코드가 하부의 구체적인 코드를 호출함
	- 즉, 애플리케이션의 코드가 재사용 가능한 라이브러리나 툴킷(toolkit)의 코드를 호출한다.
- 의존성을 역전시킨 객체지향 구조 : 
	- 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출한다.
	- 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다.
	- 즉, 의존성을 역전시키면 제어 흐름의 주체 역시 역전된다. (이를 제어 역전 원리라고 한다)
	- 협력을 제어하는 것은 프레임워크라는 것에 주목하자.
	- 우리의 코드는 수동적인 존재다.
