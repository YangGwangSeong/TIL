- *상속의 목적은 코드 재사용이 아니다.* 
	- *타입 계층을 구조화하기 위해 사용해야 한다.* 

상속을 이용해 자식 클래스를 추가하려 할 때
1. 상속을 사용하려는 목적이 단순히 코드를 재사용하기 위해서인가?
2. 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서인가?

> *만약 1번이 이유라면 상속을 사용하지 말아야 한다* 

> 12장 
> 이번장에서 상속의 관점에서 다형성이 구현되는 기술적인 메커니즘을 살펴보고
> 다형성이 런타임에 메세지를 처리하기에 적합한 메서드를 동적으로 탐색하는 과정을 통해 구현되며,
> 상속이 이런 메서드를 찾기 위한 일종의 탐색 경로를 클래스 계층의 형태로 구현하기 위한 방법이라는 사실을 이해하게 된다.

# 🐷 다형성
#객체지향/Polymorphism-다형성
> 다형성(Polymorphism) : "많은 형태를 가질 수 있는 능력"
> > 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력으로 정의한다.

#객체지향/객체지향프로그래밍에서-사용되는-다형성
- 객체지향 프로그래밍에서 사용되는 다형성
	- 유니버설(Universal) 다형성
		- 매개변수(Parametric) 다형성
		- 포함(Inclustion) 다형성
	- 임시(Ad Hoc) 다형성
		- 오버로딩(Overloading) 다형성
		- 강제(Coercion) 다형성

![](../images/image18.png)

- [0] 오버로딩 다형성(Overloading)
- 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우

- [1] 강제(Coercion)
- 언어가 지원하는 자동 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
	- ex) 예를 들어 자바에서 이항 연산자인 '+'는 타입에 따라 덧셈으로 동작하기도 하고 연결 동작을 하기도 한다.

```ts title="+연산자 강제 다형성"
// '+' 연산자의 강제 다형성
function addOrConcat(a: number | string, b: number | string): number | string {
  if (typeof a === "number" && typeof b === "number") {
    return a + b;
  } else if (typeof a === "string" && typeof b === "string") {
    return a + b;
  } else {
    return a + b;
  }
}

console.log(addOrConcat(5, 3)); // 출력: 8 (숫자 덧셈)
console.log(addOrConcat("Hello", "World")); // 출력: "HelloWorld" (문자열 연결)
console.log(addOrConcat(5, "3")); // 출력: "53" (숫자가 문자열로 강제 변환)
```

- [2] 매개변수 다형성(Parametric)
- *제네릭 프로그래밍* 과 관련이 높다.
- 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식

```typescript title="제네릭 매개변수 다형성"
// 제네릭 함수
function identity<T>(arg: T): T {
    return arg;
}

let output1 = identity<string>("myString");
let output2 = identity<number>(100);

console.log(output1); // 출력: myString
console.log(output2); // 출력: 100
```

- [3] 포함 다형성(Inclusion)
- 메세지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력
- 서브타입(Subtype) 다형성이라고도 부름.
- 포함 다형성은 객체지향 프로그래밍에서 가장 널리 알려진 형태의 다형성
- 포함 다형성을 위한 전제조건은 자식 클래스가 부모 클래스의 서브타입이어야 한다.
	- *상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것이다.* 

```typescript title="포함 다형성"
class Movie{
	private discountPolicy: DiscountPolicy;

	constructor(discountPolicy:DiscountPolicy){
		this.discountPolicy = discountPolicy;
	}

	public calculateMovieFee(screening: Screening){
		return fee.minus(discountPolicy.calculateDiscountAmount(screening));
	}
}
```

> 포함 다형성을 구현하는 가장 일반적인 방법은 상속이고
> 자식 클래스에서 부모 클래스의 메서드를 오버라이딩한 후 클라이언트는 부모 클래스만 참조하면 포함 다형성을 구현할 수 있다.

**12장 목표 : 포함 다형성의 관점에서 런타임에 상속 계층 안에서 적절한 메서드를 선택하는 방법을 이해하는 것** 

# 🐨 상속의 양면성
> 데이터 관점의 상속 : 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함시킬 수 있다.
> 행동 관점의 상속 : 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함시킬 수 있다.

- *상속의 목적은 코드 재사용이 아니다.* 
- 상속은 *다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다* 
- 상속 내부의 메커니즘뿐만 아니라 타입 계층을 기반으로 한 다형성의 동작 방식을 이해 할 수 있는 개념들
	- 업캐스팅
	- 동적 메서드 탐색
	- 동적 바인딩
	- self 참조
	- super 참조

## 상속을 사용한 강의 평가
> 수강생들의 성적을 계산하는 프로그램 예제
> `Pass:3 Fail:2` 강의 이수 학생수와 낙제한 학생의 수
> `A:1 B:1 C:1 D:0 F:2` 는 등급별 학생들의 분포 현황

```ts
class Lecture {
  private pass: number;
  private title: string;
  private scores: number[] = [];

  constructor(pass: number, title: string, scores: number[]) {
    this.pass = pass;
    this.title = title;
    this.scores = scores;
  }

  public get Average() {
    return this.scores.reduce((a, b) => a + b, 0) / this.scores.length;
  }

  public get Scores() {
    return this.scores;
  }

  public evaluate() {
    return `Pass: ${this.passCount()}, Fail: ${this.failCount()}`;
  }

  private passCount() {
    return this.scores.filter((score) => score >= this.pass).length;
  }

  private failCount() {
    return this.scores.filter((score) => score < this.pass).length;
  }
}

/**
 * 이수 기준이 70점인 객체지향 프로그래밍 과목의 수강생 5명에 대한 성적 통계
 */

const lecture = new Lecture(70, "객체지향 프로그래밍", [81, 95, 75, 50, 45]);

console.log(lecture.evaluate()); // Pass: 3, Fail: 2
```

### 상속을 이용해 Lecture 클래스 재사용하기
> `Lecture` 의 출력 결과에 등급별 통계를 추가

```ts
class Grade {
  private name: string;
  private upper: number;
  private lower: number;

  constructor(name: string, upper: number, lower: number) {
    this.name = name;
    this.upper = upper;
    this.lower = lower;
  }

  public get Name() {
    return this.name;
  }

  public isName(name: string) {
    return this.name === name;
  }

  public include(score: number) {
    return score >= this.lower && score <= this.upper;
  }
}

/**
 * `Lecture` 의 출력 결과에 등급별 통계를 추가
 */
class GradeLecture extends Lecture {
  private grades: Grade[];

  constructor(pass: number, title: string, grades: Grade[], scores: number[]) {
    super(pass, title, scores);
    this.grades = grades;
  }

  public override evaluate(): string {
    return super.evaluate() + `, Grade: ${this.gradesStatistics()}`;
  }

  private gradesStatistics() {
    return this.grades
      .map((grade) => {
        return this.format(grade);
      })
      .join(" ");
  }

  private format(grade: Grade) {
    return `${grade.Name}: ${this.gradeCount(grade)}`;
  }

  private gradeCount(grade: Grade) {
    return this.Scores.filter((score) => grade.include(score)).length;
  }
  /**
   * 부모 클래스에 없는 average 메서드 추가
   */
  public average() {
    return this.Scores.reduce((a, b) => a + b, 0) / this.Scores.length;
  }

  public gradeAverage(grade: Grade) {
    return (
      this.Scores.filter((score) => grade.include(score)).reduce(
        (a, b) => a + b,
        0
      ) / this.gradeCount(grade)
    );
  }
}

const lecture2 = new GradeLecture(
  70,
  "객체지향 프로그래밍",
  [
    new Grade("A", 100, 95),
    new Grade("B", 94, 80),
    new Grade("C", 79, 70),
    new Grade("D", 69, 50),
    new Grade("F", 49, 0),
  ],
  [81, 95, 75, 50, 45]
);

console.log(lecture2.evaluate()); // Pass: 3, Fail: 2, Grade: A: 1 B: 1 C: 1 D: 1 F: 1
console.log(lecture2.average()); // 71
console.log(lecture2.gradeAverage(new Grade("A", 100, 95))); // 95
```

> `GradeLecture` 의 `evaluate` 메서드에서는 예약어 `super` 를 이용해 `Lecture` 클래스의 `evaluate` 메서드를 먼저 실행 한다는 사실을 눈여겨 봐라.

## 데이터 관점의 상속
#객체지향/데이터관점의상속

```ts
const lecture = new GradeLecture(
  70,
  "객체지향 프로그래밍",
  [
    new Grade("A", 100, 95),
    new Grade("B", 94, 80),
    new Grade("C", 79, 70),
    new Grade("D", 69, 50),
    new Grade("F", 49, 0),
  ],
  [81, 95, 75, 50, 45]
);
```

- *데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 볼 수 있다.* 
- *자식 클래스의 인스턴스는 자동으로 부모 클래스에 정의한 모든 인스턴스 변수를 내부에 포함하게 되는 것이다.* 

![](../images/image19.png)
## 행동 관점의 상속
#객체지향/행동관점의상속

> 데이터 관점의 상속 -> 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함
> 행동 관점의 상속 -> 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것

- 부모 클래스의 모든 퍼블릭 메서드는 자식 클래스의 퍼블릭 인터페이스에 포함된다.
- 외부 객체가 부모 클래스의 인스턴스에게 전송할 수 있는 모든 메세지는 자식 클래스의 인스턴스에게도 전송 할 수 있다.

> 부모 클래스에서 구현한 메서드를 자식 클래스의 인스턴스에서 수행할 수 있는 이유

- 런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색하기 때문이다.
- 객체의 경우에는 서로 다른 상태를 저장할 수 있도록 각 인스턴스별로 독립적인 메모리를 할당받아야 한다.
- 메서드의 경우에는 동일한 클래스의 인스턴스까지 공유가 가능하기 때문에 클래스는 한 번만 메모리에 로드하고 각 인스턴스별 클래스를 가리키는 포인터를 갖게 하는것이 경제적이다.

# 🍑 업캐스팅과 동적 바인딩

## 같은 메세지 , 다른 메서드
> 성적 계산 프로그램 예제에 각 교수별로 강의 대한 성적 통계를 계산하는 기능 추가
> 통계를 계산하는 책임은 `Professor` 클래스로 담당 

```ts
/**
 * compileStatistics 메서드는 통계 정보 생성
 * Lecture의 evaludate 메서드와 average 메서드 호출.
 */
class Professor {
  private name: string;
  private lecture: Lecture;

  constructor(name: string, lecture: Lecture) {
    this.name = name;
    this.lecture = lecture;
  }

  compileStatistics() {
    return `[${this.name}] ${this.lecture.evaluate()} - Avg: ${
      this.lecture.Average
    }`;
  }
}

/**
 * 다익스트라 교수가 강의하는 알고리즘 과목의 성적 통계
 */
const professor = new Professor(
  "다익스트라",
  new Lecture(70, "알고리즘", [81, 95, 75, 50, 45])
);
console.log(professor.compileStatistics()); // 결과 => "[다익스트라] Pass:3 Fail:2 - Avg: 69.2"

/*
* 출력
* 부모 Lecture evaluate
* 부모 Lecture Average
* [다익스트라] Pass: 3, Fail: 2 - Avg: 69.2
*/

/**
 * If Lecture 클래스 대신 자식 클래스인 GradeLecture의 인스턴스를 전달하면 어떻게 될까?
 */
const professor2 = new Professor(
  "다익스트라",
  new GradeLecture(
    70,
    "알고리즘",
    [
      new Grade("A", 100, 95),
      new Grade("B", 94, 80),
      new Grade("C", 79, 70),
      new Grade("D", 69, 50),
      new Grade("F", 49, 0),
    ],
    [81, 95, 75, 50, 45]
  )
);

console.log(professor2.compileStatistics()); // [다익스트라] Pass: 3, Fail: 2, Grade: A: 1 B: 1 C: 1 D: 1 F: 1 - Avg: 69.2

/*
* 자식 GradeLecture evaluate
* 부모 Lecture evaluate - super로 호출하는거 때문에 호출되는거 
* 부모 Lecture Average
* [다익스트라] Pass: 3, Fail: 2, Grade: A: 1 B: 1 C: 1 D: 1 F: 1 - Avg: 69.2
*/
```

```ts title="출력"
[다익스트라] Pass: 3, Fail: 2 - Avg: 69.2
자식 GradeLecture evaluate
부모 Lecture evaluate
부모 Lecture Average
[다익스트라] Pass: 3, Fail: 2, Grade: A: 1 B: 1 C: 1 D: 1 F: 1 - Avg: 69.2
```

> *Professor* 생성자의 2번째 인자타입은 *Lecture* 로 선언돼 있지만 `GradeLecture` 의 인스턴스를 전달하더라도 아무 문제 없이 실행된다는것 알 수 있다!!!
> 동일한 객체 참조인 `lecture` 에 대해 동일한 `evaluate` 메세지를 전송하는 동일한 코드 안에서 서로 다른 클래스 안에 구현된 메서드를 실행할 수 있다는 사실을 알 수 있다.

**코드 안에서 선언된 참조 타입과 무관하게 실제 메세지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것은 업캐스팅과 동적 바인딩 이라는 메커니즘이 작용하기 때문** 

#객체지향/업캐스팅 , #객체지향/동적바인딩

- *업캐스팅* : 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다.
- *동적 바인딩* : 선언된 변수의 타입이 아니라 메세지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다.
	- 이것은 객체지향 시스템이 메세지를 처리할 적절한 메서드를 **컴파일 시점이 아니라 실행 시점에 결정하기 떄문에 가능하다** 
