
# 오브젝트
![](./images/image01.png)
# 🔑 요약
# 1장 
- *의존성* 을 제거함으로써 객체 사이의 *결합도* 를 낮추고 낮추기 위한 방법으로 *캡슐화* 하여 객체의 *자율성* 을 높이고 *응집도* 높은 객체들의 공동체를 창조 할 수 있게 되는것이 훌륭한 객체지향 설계이다.
# 2장
- 클래스 추상 클래스, 인터페이스를 조합해서 객체지향 프로그램을 구조화하는 기본적인 방법
- 상속을 이용해 다형성을 구현 하는 기법
- 다형성이 지연 바이딩이라는 메커니즘을 통해 구현된다는 사실
- 상속은 코드를 재사용할 수 있는 가장 널리 알려진 방법이지만 캡슐화의 측면에서 합성이 더 좋은 방법
- 유연한 객체 지향 프로그램을 위해서는 컴파일 시간 의존성과 실행 시간 의존성이 달라야 한다는 사실

# 3장
- 객체지향에서 **협력**은 객체 간 상호작용을 통해 기능을 구현하는 핵심이며, **책임**과 **역할**은 협력 안에서 객체들이 수행하는 행동과 위치를 결정합니다.
- 설계는 역할과 책임을 기반으로 이루어지며, **추상화된 역할**을 통해 유연하고 재사용 가능한 시스템을 만들 수 있습니다.
- **객체의 행동이 상태를 결정**하며, 협력에 필요한 책임을 객체에게 적절히 할당하는 것이 중요합니다.
- *객체지향 설계에서 가장 중요한 것은 책임이다* 

## 책임 주도 설계
- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

## 메세지가 객체를 선택하게 하라
1. 객체가 *최소한의 인터페이스* 를 가질 수 있게 된다.
2. 객체가 충분히 *추상적인 인터페이스* 를 가질 수 있게 된다.

## 행동이 상태를 결정한다
- 객체가 가질 수 있는 상태는 행동을 결정하고 나서야 비로소 결정할 수 있다.

# 4장
## 캡슐화
- 변경 가능성이 높은 부분을 *구현* , 상대적으로 안정적인 부분을 *인터페이스* 
- 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서 인터페이스에만 의존하도록 관계를 조절하는 것이다.
- *캡슐화* 
	- 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법.
	- 변경 될 수 있는 어떤 것이라도 캡슐화 해야 한다.

## 응집도와 결합도
### 변경의 관점에서 응집도
> 변경의 관점에서 응집도란 *변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도* 

- 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높다.
- 모듈 일부만 변경된다면 응집도가 낮다.
- 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높다.
- 다수의 모듈이 함께 변경돼야 한다면 응집도가 낮다.
### 변경의 관점에서 결합도
> 변경의 관점에서 결합도란 *한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도* 

- 하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는지를 나타낸다.
- 결합도가 높을수록 함께 변경해야 하는 모듈의 수가 늘어나기 때문에 변경하기가 어렵다.
- 내부 구현을 변경 했을 때 이것이 다른 모듈에 영향을 미치는 경우에는 두 모듈 사이의 결합도가 높다고 표현한다.
- Public interface를 수정 했을 때만 다른 모듈에 영향을 미치는 경우에는 결합도가 낮다고 표현한다.
- 클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.
### 결론
- 응집도와 결합도는 변경과 관련이 깊다.
- 캡슐화의 정도가 응집도와 결합도에 영향을 미친다.

## 데이터 중심 설계 단점
- 캡슐화 위반
- 높은 결합도
- 낮은 응집도

# 5장
> 데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해서는 두 가지 원칙을 따라야 한다.

- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라

## 책임 할당을 위한 GRASP 패턴
- INFROMATION EXPERT (정보 전문가)패턴 : 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것.
- LOW COUPLING(낮은 결합도) 패턴
- HIGH COHESION(높은 응집도) 패턴
- CREATOR(창조자) 패턴
- POLYMORPHISM(다형성) 패턴
- PROTECTED VARIATIONS(변경 보호) 패턴


## 높은 응집도와 낮은 결합도
> GRASP에서 LOW COUPLING(낮은 결합도) 패턴과 HIGH COHESION(높은 응집도) 패턴

- LOW COUPLING(낮은 결합도) 패턴
	- 어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까?
	- 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.
- HIGH COHESION(높은 응집도) 패턴
	- 어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가?
	- 높은 응집도를 유지할 수 있게 책임을 할당하라.
### 클래스 응집도 판단하기
> 응집도가 낮다는 것은 서로 연관성이 없는 기능이나 데이터가 하나의클래스 안에 뭉쳐져 있다는 것을 의미한다.

1. 클래스가하나 이상의 이유로 변경 돼야 한다면 응집도가 낮은 것이다. 
2. 인스턴스 변수가 초기화 되는 시점
	- 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
	- 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화 하고 일부는 초기화되지 않은 상태로 남겨진다.
3. 메서드들이 인스턴스 변수를 사용하는 방식
	- 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다.
	- 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 응집도가 낮다.

#### 응집도가 높은 클래스를 만드려면
- *변경의 이유를 기준으로 클래스를 분리하라* 
- *함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.* 
- *속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.* 

## 다형성
> GRASP에서 POLYMORPHISM(다형성) 패턴 : 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라는것.

- 추상 클래스나 인터페이스를 사용
- 프로그램을 if ~ else 또는 switch ~ case 등의 조건 논리를 사용해서 설계 한다면 새로운 변화가 일어난 경우 조건 논리를 수정해야 한다. 
- **다형성을 이용해 새로운 변화를 다루기쉽게 확장하라고 권고한다.** 

## 변경 보호 패턴
- *설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하라* 


# 6장
- *메서드* : 메세지를 수신했을 때 실제로 실행되는 함수 또는 프로시저
- 메세지 전송자와 메세지 수신자는 서로에 대한 상세한 정보를 알지 못한 채 메세지라는 끈을 통해서만 연결된다.
- 실행 시점에 메세지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춘다.

> 전통적인 방식의 개발자는 코드의 의미가 컴파일 시점과 실행 시점에 동일한 코드를 작성하는데
> 객체지향적인 방식의 객체는 메세지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에
> **컴파일 시점과 실행 시점의 의미가 달라질 수 있다.** 
> **실행 시점에 실제로 실행되는 코드는 메세지를 수신하는 객체의 타입에 따라 달리지기 때문에** 우리는 그저 메세지에 응답할 수 있는 객체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라고 믿을 수 밖에 없다.

- 퍼블릭 인터페이스(public interface) : 객체가 의사소통을 위해 외부에 공개하는 메세지의 집합
- 오퍼레이션(operation) : 퍼블릭 인터페이스에 포함된 메세지.
	- 수행 가능한어떤 행동에 대한 추상화
- 메서드 : 메세지를 수신했을 때 실제로 실행되는 코드

> 예제 코드에서 `DiscountCondition` 인터페이스에서 `isSatisfiedBy` 가 *오퍼레이션* 이고
> `SequenceCondition` 과 `PeriodCondition` 에 정의된 각각의 `isSatisfiedBy` 는 실제 구현을 포함하기 때문에 *메서드* 라고 한다.

## 좋은 인터페이스
- 좋은 인터페이스는 *최소한의 인터페이스* 와 *추상적인 인터페이스* 라는 조건을 만족해야 한다.
- 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법은 책임 주도 설계(RDD) 방법 이다.

- [0] 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법

- 디미터 법칙
- 묻지 말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리

- **디미터 법칙을 위반하는 설계는 인터페이스와 구현의 분리 원칙(ISP: Interface Segregaion Principle)** 을 위반한다.

## 책임에 초점을 맞춰라
- *책임 주도 설계 방법에 따라 메세지를 먼저 선택하고 그 후에 메세지를 처리할 객체를 선택해라* 그렇게 하면 디미터 법칙을 준수하고, 묻지말고 시켜라 스타일을 따르면서, 의도를 드러내는 인터페이스를 설계, 명령과 쿼리 분리 설계 할 수 있다.  

# 8장
### 런타임 의존성
- 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다.
- ex) Movie클래스와 AmountDiscountPolicy, PercentDiscountPolicy클래스 간의 의존성
### 컴파일 타임 의존성
- 컴파일 타임 의존성이 다루는 주제는 클래스 사이의 의존성이다.
- ex) Movie클래스와 DiscountPolicy 클래스간의 의존성

*컴파일타임 구조와 런타임 구조사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.* 
## 의존성 해결하기
- 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다.
- 의존성 해결 : 컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것
	- 객체를 실행하는 시점에 생성자를 통해 의존성 해결
	- 객체 생성 후 setter 메소드를 이용해 의존성 해결
	- 메서드 실행 시 인자를 이용해 의존성 해결
### 결론
- *메서드가 실행되는 동안만 일시적으로 의존 관계가 존재해도 무방하거나,* *메서드가 실행될 때마다 의존 대상이 매번 달라져야 하는 경우* 메서드 실행 시 인자를 이용해 의존성 해결하면 유용하다
- 클래스의 메서드를 호출하는 대부분의 경우에 매번 동일한 객체를 인자로 전달하고 있다면 *생성자를 이용하는 방식* 이나 *setter* 메서드를 이용해 의존성을 지속적으로 유지하는 방식을 사용하는것이 좋다.

## 의존성과 결합도
### 결론
- 서로에 대해 알고 있는 지식의 양이 결합도를 결정한다.
	- Movie클래스가 DiscountPolicy 클래스를 의존하면 구체적인 계산 알 필요가 없기 때문에 결합도가 낮다.
	- Movie 클래스가 PercentDiscountPolicy 클래스에 의존하면 협력할 객체가 비율 할인 정책에 따라 할인 요금을 계산 할 것이라는것을 알고 있다.
- 결합도를 느슨하게 만들려면 추상화가 가장 효과적이고 `DiscountPolicy` 클래스는`PercentDiscountPolicy` 클래스가 비율 할인 정책에 따라 할인 요금을 계산 한다는 사실을 숨겨주기 때문에 `PercentDiscountPolicy` 의 추상화다.
- 의존성을 `new` 를 통해 구현 내부에 숨겨두면 결합도가 높아진다. 의존성을 구현 내부에 숨겨두지말고 퍼블릭 인터페이스(public interface)를 통해 의존성은 명시적으로 표현되어야 한다.

> DiscountPolicy와 PercentDiscountPolicy(비율 할인 정책), AmountDiscountPolicy(금액 할인 정책), OverlappedDiscountPolicy(중복 할인), NoneDiscountPolicy(할인 없음) 추상화된 DiscountPolicy를 통해 재사용 가능한 설계를 가진다. 


# 📆 정리 현황 테이블

아래 테이블에 각 장별로 작성한 README.md 를 링크 (연결) 합니다.

| Priority | Task              | Chapter | Link                                                                                                                                                                                                                                       |
| -------- | ----------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ⭐⭐⭐⭐⭐    | 1. 객체, 설계         | 1장      | [링크](https://github.com/yanggwangseong/TIL/blob/main/%EB%8F%84%EC%84%9C/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/Chapter/1.%20%EA%B0%9D%EC%B2%B4%2C%20%EC%84%A4%EA%B3%84.md)                                                                   |
| ⭐⭐⭐      | 2. 객체지향 프로그래밍     | 2장      | [링크](https://github.com/yanggwangseong/TIL/blob/main/%EB%8F%84%EC%84%9C/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/Chapter/2.%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.md)                         |
| ⭐⭐⭐⭐⭐    | 3. 역할, 책임, 협력     | 3장      | [링크](https://github.com/yanggwangseong/TIL/blob/main/%EB%8F%84%EC%84%9C/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/Chapter/3.%20%EC%97%AD%ED%95%A0%2C%20%EC%B1%85%EC%9E%84%2C%20%ED%98%91%EB%A0%A5.md)                                           |
| ⭐⭐       | 4. 설계 품질과 트레이드 오프 | 4장      | [링크](https://github.com/yanggwangseong/TIL/blob/main/%EB%8F%84%EC%84%9C/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/Chapter/4.%20%EC%84%A4%EA%B3%84%20%ED%92%88%EC%A7%88%EA%B3%BC%20%ED%8A%B8%EB%A0%88%EC%9D%B4%EB%93%9C%20%EC%98%A4%ED%94%84.md) |
| ⭐⭐⭐      | 5. 책임 할당하기        | 5장      | [링크](https://github.com/yanggwangseong/TIL/blob/main/%EB%8F%84%EC%84%9C/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/Chapter/5.%20%EC%B1%85%EC%9E%84%20%ED%95%A0%EB%8B%B9%ED%95%98%EA%B8%B0.md)                                                    |
| ⭐⭐       | 6. 메세지와 인터페이스     | 6장      |                                                                                                                                                                                                                                            |
| ⭐        | 7. 객체 분해          | 7장      |                                                                                                                                                                                                                                            |
| ⭐⭐⭐      | 8. 의존성 관리하기       | 8장      |                                                                                                                                                                                                                                            |

# 📝 키워드
#객체지향/depencency , #객체지향/coupling , #객체지향/encapsulation , #객체지향/cohesion

