
## 객체, 그리고 이상한 나라

### 앨리스 객체

이상한 나라의 앨리스의 주인공 앨리스를 예시로 들어보자.

> 앨리스는 버섯의 한쪽을 먹어 몸을 키우다가 몸이 너무 커지면 반대 쪽을 먹어 몸을 작게 줄였다. 커졌다 작아지고, 작아졌다 커지기를 반복하던 앨리스는 마침내 몸의 크기를 원래 상태로 돌릴 수 있었다.

여기서 나오는 앨리스의 특징은 객체의 특징과 같다

- 앨리스는 상태를 가지며 상태는 변경 가능하다.
- 앨리스의 상태를 변경시키는 것은 앨리스의 행동이다.
	- 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
	- 행동의 순서가 결과에 영향을 미친다.
- 앨리스는 어떤 상태에 있더라도 유일하게 식별 가능하다.


## 객체, 그리고 소프트웨어 나라

- 객체

> 식별 가능한 개체 또는 사물일 수도, 구체적인 사물일 수도, 추상적일 수도 있다.
> **구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태**를 가진다.

### 상태
> 객체가 주변 환경과의 상호작용에 어떻게 반응하는가는 그 시점까지 객체에 어떤 일이 발생했느냐에 좌우된다.
> 어떤 행동의 결과는 과거에 어떤 행동들이 일어났었느냐에 의존한다는 것이다.
> **상태**를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해할 수 있다. 복잡성과 인지 부조화를 줄일 수 있는 중요한 개념이다.


![[Pasted image 20240716233600.png]]

> **객체를 사용해 다른 객체의 상태를 표현해야 할때가 있다** 
> 앨리스가 현재 음료를 들고 있는 상태인지를 표현하고 싶다면 어떻게 할 것인가?

- 앨리스와 음료는 객체
- 앨리스의 키와 위치, 음료의 양은 객체가 아닌 단순한 값이다.

> 앨리스 객체와 음료 객체는 서로 연결 되어 있을 때
> 앨리스를 기준으로 앨리스의 상태는 키와 위치라는 단순한 값과 음료라는 객체의 조합으로 표현할 수 있다.

- [n] comment

```ts
// 앨리스라는 객체 
@Injectable()
export class AliceService {

	// 앨리스의 상태는 키와 위치라는 단순한 값과 음료라는 객체의 조합
	private _height: number;
	private _location: string;
  
	constructor(private readonly drink: DrinkService) {
		this._height = 130;
		this._location = '통로';
	}

	get height() {
		return this._height;
	}
	
	get location() {
		return this._location;
	}
	
	set height(height: number) {
		this._height = height;
	}
	
	set location(location: string) {
		this._location = location;
	}

}

// 음료라는 객체
@Injectable()
export class Drink {
	private _size: number;

	constructor() {
		this._size = 0.5;
	}
	
	set size(size) {
		this._size = size;
	}
	
	get size() {
		return this._size;
	}
}

const alice = new Alice();
```

![[Pasted image 20240716235107.png]]

> 앨리스는 키가 130센티미터이고 통로에 위치하고 있으며 0.5리터 크기의 음료를 가지고 있다.

- 객체의 상태 구성
	- 프로퍼티 : 객체의 상태를 구성하는 모든 특징. 일반적으로 정적이다.
	- 프로퍼티 값: 시간의 흐름에 따라 변경되기 때문에 동적이다.
- 객체의 프로퍼티 구분
	- 링크: 객체와 객체 사이의 의미 있는 연결, 링크가 있어야만 요청을 보내고 받을 수 있다.
	- 속성: 객체를 구성하는 단순한 값.



### 행동
> 객체의 행동은 객체의 상태를 변경시키지만 행동의 결과는 객체의 상태에 의존적이다.

- 음료를 마신 후의 앨리스의 키는 음료를 마시기 전의 앨리스의 키보다 작아져야 한다. -> 음료를 마시는 행동의 결과가 앨리스의 키에 의존

#### 상태와 행동 사이의 관계
- 객체의 행동은 상태에 영향을 받는다
- 객체의 행동은 상태를 변경시킨다

> 행동은 다음 두 side effect를 명확하게 서술해야 한다.

- 객체 자신의 상태 변경
- 행동 내에서 협력하는 다른 객체에 대한 메세지 전송

![[Pasted image 20240718030908.png]]

> 메세지를 전송하는 객체나 메세지 송신자는 메세지 수신자의 상태 변경에 대해서 전혀 알지 못한다.
> 이를 *캡슐화* 라고 한다.

**상태를 잘 정의된 행동 집합 뒤로 캡슐화 하는 것은 객체의 자율성을 높이고 협력을 단순화하고 유연하게 만든다. 이것이 상태를 캡슐화 해야 하는 이유다** 


### 식별자

- 값
> 숫자, 문자열, 날짜, 금액 등과 같이 변하지 않는 양을 모델링 한다.
> 값의 상태는 변하지 않기 때문에 *불변 상태(immutable state)* 
> 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 *동등성(equality)* 이라고 한다.

- 객체
> 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질을 *동일성(identical)* 이라고 한다.
#### 객체의 특성
- 객체는 상태를 가지며 상태는 변경 가능하다.
- 객체의 상태를 변경시키는 것은 객체의 행동이다.
	- 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
	- 행동의 순서가 실행 결과에 영향을 미친다.
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.



## 행동이 상태를 결정한다
> 객체 지향 설계시 상태를 먼저 결정 했을때 

1. 상태를 먼저 결정할 경우 캡슐화가 저해된다. 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화 되지 못하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다.
2. 객체를 협력자가 아닌 고립된 섬으로 만든다. 상태를 먼저 고려하는 방식은 협력이라는 문제에서 멀리 벗어난 채 객체를 설계하게 함으로써 자연스럽게 협력에 적합하지 못한 객체를 창조하게 된다.
3. 객체의 재사용성이 저하된다. 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나온다. 협력에 참여하기 어려워 지게 되면 재사용성이 저하된다.

> 객체를 설계 할때 상태가 아니라 행동에 초점을 맞춰야 한다.
> 객체는 협력하기 위해 존재하며, 협력을 위한 수단은 행동이기 때문에 설계자로서 행동에 초점을 맞춰야 한다.

**행동이 상태를 결정한다** 



